#!/usr/bin/env tsx
/**
 * Generate TypeScript types from translation files
 * 
 * This script reads the English translation file (en.json) and generates
 * TypeScript types for all translation keys, enabling autocomplete and
 * compile-time validation of translation keys.
 * 
 * Usage: npm run generate-types
 */

import * as fs from 'fs';
import * as path from 'path';

// Paths
const TRANSLATIONS_PATH = path.join(process.cwd(), 'public/locales/en.json');
const OUTPUT_PATH = path.join(process.cwd(), 'lib/i18n/translation-keys.ts');

/**
 * Recursively generate dot-notation keys from nested object
 */
function generateKeys(obj: any, prefix: string = ''): string[] {
  const keys: string[] = [];
  
  for (const key in obj) {
    const fullKey = prefix ? `${prefix}.${key}` : key;
    
    if (typeof obj[key] === 'object' && obj[key] !== null && !Array.isArray(obj[key])) {
      // Nested object - recurse
      keys.push(...generateKeys(obj[key], fullKey));
    } else {
      // Leaf node - add the key
      keys.push(fullKey);
    }
  }
  
  return keys;
}

/**
 * Generate TypeScript union type from keys
 */
function generateTypeDefinition(keys: string[]): string {
  const sortedKeys = keys.sort();
  const keyLiterals = sortedKeys.map(key => `  | '${key}'`).join('\n');
  
  return `/**
 * Auto-generated translation keys
 * 
 * This file is automatically generated from public/locales/en.json
 * DO NOT EDIT MANUALLY - Run 'npm run generate-types' to regenerate
 * 
 * Generated: ${new Date().toISOString()}
 */

/**
 * All available translation keys in dot notation
 * Provides autocomplete and compile-time validation
 */
export type TranslationKey =
${keyLiterals};

/**
 * Total number of translation keys: ${keys.length}
 */
export const TRANSLATION_KEY_COUNT = ${keys.length};

/**
 * All translation keys as an array (useful for validation)
 */
export const ALL_TRANSLATION_KEYS: TranslationKey[] = [
${sortedKeys.map(key => `  '${key}',`).join('\n')}
];

/**
 * Check if a string is a valid translation key
 */
export function isValidTranslationKey(key: string): key is TranslationKey {
  return ALL_TRANSLATION_KEYS.includes(key as TranslationKey);
}
`;
}

/**
 * Main execution
 */
function main() {
  console.log('ğŸ”„ Generating translation types...\n');
  
  // Read translation file
  console.log(`ğŸ“– Reading translations from: ${TRANSLATIONS_PATH}`);
  if (!fs.existsSync(TRANSLATIONS_PATH)) {
    console.error(`âŒ Error: Translation file not found at ${TRANSLATIONS_PATH}`);
    process.exit(1);
  }
  
  const translationsContent = fs.readFileSync(TRANSLATIONS_PATH, 'utf-8');
  const translations = JSON.parse(translationsContent);
  
  // Generate keys
  console.log('ğŸ” Extracting translation keys...');
  const keys = generateKeys(translations);
  console.log(`âœ… Found ${keys.length} translation keys`);
  
  // Generate TypeScript definition
  console.log('ğŸ“ Generating TypeScript types...');
  const typeDefinition = generateTypeDefinition(keys);
  
  // Ensure output directory exists
  const outputDir = path.dirname(OUTPUT_PATH);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }
  
  // Write output file
  console.log(`ğŸ’¾ Writing types to: ${OUTPUT_PATH}`);
  fs.writeFileSync(OUTPUT_PATH, typeDefinition, 'utf-8');
  
  console.log('\nâœ¨ Translation types generated successfully!');
  console.log(`\nğŸ“Š Summary:`);
  console.log(`   - Total keys: ${keys.length}`);
  console.log(`   - Output file: ${OUTPUT_PATH}`);
  console.log(`\nğŸ’¡ Next steps:`);
  console.log(`   1. Import TranslationKey in lib/i18n/types.ts`);
  console.log(`   2. Use it in your translation function`);
  console.log(`   3. Enjoy autocomplete and type safety! ğŸ‰`);
}

// Run the script
try {
  main();
} catch (error) {
  console.error('âŒ Error generating translation types:', error);
  process.exit(1);
}
